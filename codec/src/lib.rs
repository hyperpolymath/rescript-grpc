// SPDX-License-Identifier: MPL-2.0
//! WASM codec library for ReScript protobuf support
//!
//! This library provides the allocator and encode/decode functions
//! that are called from ReScript via the WASM interface.
//!
//! Generated message structs and their codec functions will be
//! added to this crate by protoc-gen-rescript when --rescript_opt=wasm
//! is specified.

#![no_std]

extern crate alloc;

use alloc::vec::Vec;
use core::slice;

// Use wee_alloc for smaller WASM binary size
#[global_allocator]
static ALLOC: wee_alloc::WeeAlloc = wee_alloc::WeeAlloc::INIT;

/// Allocate memory for use by ReScript
///
/// # Safety
/// The caller must ensure the returned pointer is eventually freed
/// using the `free` function.
#[no_mangle]
pub extern "C" fn alloc(size: usize) -> *mut u8 {
    let mut buf = Vec::with_capacity(size);
    let ptr = buf.as_mut_ptr();
    core::mem::forget(buf);
    ptr
}

/// Free memory previously allocated by `alloc`
///
/// # Safety
/// The pointer must have been returned by `alloc` and not already freed.
#[no_mangle]
pub unsafe extern "C" fn free(ptr: *mut u8, size: usize) {
    if !ptr.is_null() && size > 0 {
        let _ = Vec::from_raw_parts(ptr, 0, size);
    }
}

/// Get a slice from a pointer and length
///
/// # Safety
/// The pointer must be valid for `len` bytes.
#[inline]
pub unsafe fn slice_from_ptr<'a>(ptr: *const u8, len: usize) -> &'a [u8] {
    if ptr.is_null() || len == 0 {
        &[]
    } else {
        slice::from_raw_parts(ptr, len)
    }
}

/// Get a mutable slice from a pointer and length
///
/// # Safety
/// The pointer must be valid for `len` bytes and not aliased.
#[inline]
pub unsafe fn slice_from_ptr_mut<'a>(ptr: *mut u8, len: usize) -> &'a mut [u8] {
    if ptr.is_null() || len == 0 {
        &mut []
    } else {
        slice::from_raw_parts_mut(ptr, len)
    }
}

// ============================================================================
// Result encoding for ReScript
// ============================================================================

/// Result struct passed back to ReScript
/// First 4 bytes: pointer to data
/// Next 4 bytes: length of data (or error code if negative)
#[repr(C)]
pub struct WasmResult {
    pub ptr: *mut u8,
    pub len: i32,
}

impl WasmResult {
    pub fn ok(ptr: *mut u8, len: usize) -> Self {
        Self {
            ptr,
            len: len as i32,
        }
    }

    pub fn err(code: i32) -> Self {
        Self {
            ptr: core::ptr::null_mut(),
            len: -code,
        }
    }
}

// ============================================================================
// Example: User message (this would be generated by protoc-gen-rescript)
// ============================================================================

// This is a placeholder showing the pattern. Actual message types
// will be generated and added to this crate.

/*
use prost::Message;

#[derive(Clone, PartialEq, Message)]
pub struct User {
    #[prost(string, tag = "1")]
    pub name: String,
    #[prost(int32, tag = "2")]
    pub id: i32,
    #[prost(string, optional, tag = "3")]
    pub email: Option<String>,
}

#[no_mangle]
pub extern "C" fn encode_user(ptr: *const u8, len: usize) -> WasmResult {
    // Decode User from ReScript's serialization format
    // Encode to protobuf wire format
    // Return pointer + length
    todo!()
}

#[no_mangle]
pub extern "C" fn decode_user(ptr: *const u8, len: usize) -> WasmResult {
    // Decode from protobuf wire format
    // Serialize to ReScript's format
    // Return pointer + length
    todo!()
}
*/

// Panic handler for no_std
#[cfg(not(test))]
#[panic_handler]
fn panic(_info: &core::panic::PanicInfo) -> ! {
    loop {}
}
